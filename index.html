<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Conductor Workflow Visualizer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            background: #f5f7fa;
            color: #2c3e50;
            overflow: hidden;
            height: 100vh;
        }

        #header {
            background: #fff;
            border-bottom: 1px solid #e1e8ed;
            padding: 16px 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }

        #header h1 {
            font-size: 18px;
            font-weight: 600;
            color: #2c3e50;
        }

        #controls {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
        }

        .file-input-wrapper input[type=file] {
            position: absolute;
            left: -9999px;
        }

        .file-input-wrapper label {
            display: inline-block;
            padding: 8px 16px;
            background: #3498db;
            color: white;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: background 0.2s;
        }

        .file-input-wrapper label:hover {
            background: #2980b9;
        }

        button {
            padding: 8px 16px;
            background: white;
            color: #2c3e50;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.2s;
        }

        button:hover {
            background: #f9fafb;
            border-color: #9ca3af;
        }

        #canvas-container {
            width: 100%;
            height: calc(100vh - 60px);
            overflow: hidden;
            position: relative;
            background: #ffffff;
            cursor: grab;
        }

        #canvas-container:active {
            cursor: grabbing;
        }

        svg {
            display: block;
        }

        .node {
            cursor: pointer;
            transition: all 0.2s;
        }

        .node-rect {
            transition: all 0.2s;
        }

        .node:hover .node-rect {
            filter: brightness(1.05);
            stroke-width: 2.5;
        }

        .node.has-children .node-rect {
            stroke-width: 2.5;
        }

        .node.collapsed .node-rect {
            stroke-dasharray: 4,4;
        }

        .node-text {
            pointer-events: none;
            user-select: none;
            font-size: 13px;
            font-weight: 500;
        }

        .node-type {
            pointer-events: none;
            user-select: none;
            font-size: 11px;
            opacity: 0.8;
        }

        .edge {
            fill: none;
            stroke: #cbd5e0;
            stroke-width: 2;
            transition: all 0.2s;
        }

        .collapse-indicator {
            transition: all 0.2s;
        }

        .collapse-indicator circle {
            fill: white;
            stroke: currentColor;
            stroke-width: 2;
        }

        .collapse-indicator text {
            font-size: 14px;
            font-weight: bold;
            fill: currentColor;
        }

        #info-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            max-width: 320px;
            display: none;
            border: 1px solid #e1e8ed;
        }

        #info-panel.show {
            display: block;
            animation: slideIn 0.2s ease;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        #info-panel h3 {
            font-size: 15px;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 12px;
            word-break: break-word;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #f0f0f0;
            font-size: 12px;
        }

        .info-row:last-child {
            border-bottom: none;
        }

        .info-label {
            color: #6b7280;
            font-weight: 500;
        }

        .info-value {
            color: #2c3e50;
            font-weight: 600;
            text-align: right;
            word-break: break-all;
            max-width: 180px;
        }

        .status-badge {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .status-COMPLETED {
            background: #d4edda;
            color: #155724;
        }

        .status-FAILED {
            background: #f8d7da;
            color: #721c24;
        }

        .status-RUNNING {
            background: #fff3cd;
            color: #856404;
        }

        .status-SCHEDULED {
            background: #d1ecf1;
            color: #0c5460;
        }

        .status-SKIPPED {
            background: #e2e3e5;
            color: #383d41;
        }

        #legend {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: white;
            padding: 16px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            border: 1px solid #e1e8ed;
        }

        #legend h4 {
            font-size: 12px;
            font-weight: 600;
            margin-bottom: 12px;
            color: #6b7280;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            font-size: 12px;
        }

        .legend-item:last-child {
            margin-bottom: 0;
        }

        .legend-color {
            width: 24px;
            height: 24px;
            margin-right: 10px;
            border-radius: 4px;
            border: 1px solid #e1e8ed;
            flex-shrink: 0;
        }

        #stats {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: white;
            padding: 16px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            border: 1px solid #e1e8ed;
            font-size: 12px;
        }

        #stats h4 {
            font-size: 12px;
            font-weight: 600;
            margin-bottom: 12px;
            color: #6b7280;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
            gap: 20px;
        }

        .stat-row:last-child {
            margin-bottom: 0;
        }

        .stat-label {
            color: #6b7280;
        }

        .stat-value {
            font-weight: 600;
            color: #2c3e50;
        }

        #empty-state {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #9ca3af;
        }

        #empty-state svg {
            width: 80px;
            height: 80px;
            margin-bottom: 16px;
            opacity: 0.5;
        }

        #empty-state h2 {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 8px;
            color: #6b7280;
        }

        #empty-state p {
            font-size: 14px;
        }

        .close-btn {
            position: absolute;
            top: 12px;
            right: 12px;
            background: none;
            border: none;
            font-size: 20px;
            color: #9ca3af;
            cursor: pointer;
            padding: 4px;
            line-height: 1;
        }

        .close-btn:hover {
            color: #6b7280;
        }
    </style>
</head>
<body>
    <div id="header">
        <h1>Conductor Workflow Visualizer</h1>
        <div id="controls">
            <div class="file-input-wrapper">
                <input type="file" id="fileInput" accept=".json">
                <label for="fileInput">Load Workflow</label>
            </div>
            <button onclick="expandAll()">Expand All</button>
            <button onclick="collapseAll()">Collapse All</button>
            <button onclick="resetView()">Reset View</button>
        </div>
    </div>

    <div id="canvas-container">
        <svg id="canvas"></svg>
        
        <div id="empty-state">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"/>
            </svg>
            <h2>No Workflow Loaded</h2>
            <p>Upload a workflow JSON file to visualize</p>
        </div>
    </div>

    <div id="info-panel">
        <button class="close-btn" onclick="closeInfo()">×</button>
        <div id="info-content"></div>
    </div>

    <div id="legend">
        <h4>Task Types</h4>
        <div class="legend-item">
            <div class="legend-color" style="background: #3b82f6;"></div>
            <span>Simple</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #8b5cf6;"></div>
            <span>Sub-Workflow</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #10b981;"></div>
            <span>Decision</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #f59e0b;"></div>
            <span>HTTP</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #ec4899;"></div>
            <span>Human</span>
        </div>
    </div>

    <div id="stats">
        <h4>Statistics</h4>
        <div class="stat-row">
            <span class="stat-label">Total Tasks:</span>
            <span class="stat-value" id="totalTasks">0</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Visible:</span>
            <span class="stat-value" id="visibleTasks">0</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Max Depth:</span>
            <span class="stat-value" id="maxDepth">0</span>
        </div>
    </div>

    <script>
        // Constants
        const NODE_WIDTH = 200;
        const NODE_HEIGHT = 70;
        const HORIZONTAL_SPACING = 280;
        const VERTICAL_SPACING = 120;
        const PADDING = 100;

        // State
        let allNodes = [];
        let allEdges = [];
        let collapsedNodes = new Set();
        let svg = document.getElementById('canvas');
        let svgGroup;
        
        // Pan & Zoom
        let viewBox = { x: 0, y: 0, width: 2000, height: 1000 };
        let isPanning = false;
        let startPoint = { x: 0, y: 0 };
        let scale = 1;

        // Initialize
        function init() {
            svgGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            svg.appendChild(svgGroup);
            updateViewBox();
            setupEventListeners();
        }

        function setupEventListeners() {
            const container = document.getElementById('canvas-container');
            
            container.addEventListener('mousedown', (e) => {
                if (e.target.closest('.node')) return;
                isPanning = true;
                startPoint = { x: e.clientX, y: e.clientY };
                e.preventDefault();
            });

            container.addEventListener('mousemove', (e) => {
                if (!isPanning) return;
                const dx = (e.clientX - startPoint.x) / scale;
                const dy = (e.clientY - startPoint.y) / scale;
                viewBox.x -= dx;
                viewBox.y -= dy;
                updateViewBox();
                startPoint = { x: e.clientX, y: e.clientY };
            });

            container.addEventListener('mouseup', () => {
                isPanning = false;
            });

            container.addEventListener('mouseleave', () => {
                isPanning = false;
            });

            container.addEventListener('wheel', (e) => {
                e.preventDefault();
                const delta = e.deltaY > 0 ? 0.9 : 1.1;
                const newScale = scale * delta;
                if (newScale < 0.1 || newScale > 3) return;
                
                scale = newScale;
                viewBox.width = 2000 / scale;
                viewBox.height = 1000 / scale;
                updateViewBox();
            });

            document.getElementById('fileInput').addEventListener('change', handleFileUpload);
        }

        function updateViewBox() {
            svg.setAttribute('viewBox', `${viewBox.x} ${viewBox.y} ${viewBox.width} ${viewBox.height}`);
        }

        function handleFileUpload(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const data = JSON.parse(event.target.result);
                    loadWorkflow(data);
                    document.getElementById('empty-state').style.display = 'none';
                } catch (error) {
                    alert('Error parsing JSON: ' + error.message);
                }
            };
            reader.readAsText(file);
        }

        // Parse workflow
        function parseWorkflow(data) {
            allNodes = [];
            allEdges = [];
            let nodeId = 0;

            function traverse(tasks, parent = null, depth = 0) {
                if (!tasks || tasks.length === 0) return;

                tasks.forEach((task, index) => {
                    const node = {
                        id: nodeId++,
                        name: task.referenceTaskName || task.taskReferenceName || task.name || 'Unnamed Task',
                        type: task.taskType || 'SIMPLE',
                        status: task.status || 'N/A',
                        parent: parent,
                        depth: depth,
                        children: [],
                        x: 0,
                        y: 0,
                        visible: true,
                        taskId: task.taskId,
                        subWorkflowId: task.subWorkflowId,
                        startTime: task.startTime,
                        endTime: task.endTime
                    };

                    allNodes.push(node);

                    if (parent) {
                        parent.children.push(node);
                        allEdges.push({ from: parent, to: node });
                    }

                    // Handle sub-workflows
                    if (task.subWorkflow && task.subWorkflow.tasks) {
                        traverse(task.subWorkflow.tasks, node, depth + 1);
                    }
                });
            }

            traverse(data.tasks || []);
        }

        // Layout algorithm
        function layoutNodes() {
            const levels = {};
            
            // Group by depth
            allNodes.forEach(node => {
                if (!levels[node.depth]) levels[node.depth] = [];
                levels[node.depth].push(node);
            });

            // Position nodes
            Object.keys(levels).forEach(depth => {
                const levelNodes = levels[depth];
                const totalWidth = levelNodes.length * HORIZONTAL_SPACING;
                const startX = -totalWidth / 2 + HORIZONTAL_SPACING / 2;

                levelNodes.forEach((node, index) => {
                    node.x = startX + index * HORIZONTAL_SPACING;
                    node.y = PADDING + parseInt(depth) * VERTICAL_SPACING;
                });
            });

            // Calculate SVG size
            const maxX = Math.max(...allNodes.map(n => n.x)) + NODE_WIDTH + PADDING;
            const minX = Math.min(...allNodes.map(n => n.x)) - PADDING;
            const maxY = Math.max(...allNodes.map(n => n.y)) + NODE_HEIGHT + PADDING;
            
            const width = Math.max(maxX - minX, 2000);
            const height = Math.max(maxY, 1000);
            
            svg.setAttribute('width', width);
            svg.setAttribute('height', height);
            
            viewBox = { x: minX, y: 0, width: width, height: height };
        }

        // Get node color
        function getNodeColor(type, status) {
            if (status === 'FAILED') return '#ef4444';
            
            const colors = {
                'SUB_WORKFLOW': '#8b5cf6',
                'DECISION': '#10b981',
                'SWITCH': '#10b981',
                'HTTP': '#f59e0b',
                'HUMAN': '#ec4899',
                'INLINE': '#06b6d4',
                'JSON_JQ_TRANSFORM': '#14b8a6',
                'SIMPLE': '#3b82f6',
                'FORK_JOIN': '#10b981',
                'JOIN': '#10b981'
            };
            return colors[type] || '#6366f1';
        }

        // Render visualization
        function render() {
            svgGroup.innerHTML = '';

            // Update visibility
            updateVisibility();

            // Draw edges
            allEdges.forEach(edge => {
                if (!edge.from.visible || !edge.to.visible) return;

                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                const fromX = edge.from.x + NODE_WIDTH / 2;
                const fromY = edge.from.y + NODE_HEIGHT;
                const toX = edge.to.x + NODE_WIDTH / 2;
                const toY = edge.to.y;
                
                const midY = (fromY + toY) / 2;
                const d = `M ${fromX} ${fromY} C ${fromX} ${midY}, ${toX} ${midY}, ${toX} ${toY}`;
                
                path.setAttribute('d', d);
                path.setAttribute('class', 'edge');
                svgGroup.appendChild(path);
            });

            // Draw nodes
            allNodes.forEach(node => {
                if (!node.visible) return;

                const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                g.setAttribute('class', 'node');
                if (node.children.length > 0) {
                    g.classList.add('has-children');
                    if (collapsedNodes.has(node.id)) {
                        g.classList.add('collapsed');
                    }
                }
                g.setAttribute('transform', `translate(${node.x}, ${node.y})`);

                // Rectangle
                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rect.setAttribute('class', 'node-rect');
                rect.setAttribute('width', NODE_WIDTH);
                rect.setAttribute('height', NODE_HEIGHT);
                rect.setAttribute('rx', 6);
                rect.setAttribute('fill', getNodeColor(node.type, node.status));
                rect.setAttribute('stroke', '#e1e8ed');
                rect.setAttribute('stroke-width', 2);
                g.appendChild(rect);

                // Node name
                const text1 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text1.setAttribute('class', 'node-text');
                text1.setAttribute('x', NODE_WIDTH / 2);
                text1.setAttribute('y', 28);
                text1.setAttribute('text-anchor', 'middle');
                text1.setAttribute('fill', '#ffffff');
                const truncated = node.name.length > 22 ? node.name.substring(0, 22) + '...' : node.name;
                text1.textContent = truncated;
                g.appendChild(text1);

                // Node type
                const text2 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text2.setAttribute('class', 'node-type');
                text2.setAttribute('x', NODE_WIDTH / 2);
                text2.setAttribute('y', 48);
                text2.setAttribute('text-anchor', 'middle');
                text2.setAttribute('fill', '#ffffff');
                text2.textContent = node.type;
                g.appendChild(text2);

                // Collapse indicator
                if (node.children.length > 0) {
                    const indicator = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    indicator.setAttribute('class', 'collapse-indicator');
                    indicator.setAttribute('transform', `translate(${NODE_WIDTH - 20}, 15)`);
                    indicator.style.color = '#ffffff';

                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('r', 10);
                    indicator.appendChild(circle);

                    const symbol = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    symbol.setAttribute('text-anchor', 'middle');
                    symbol.setAttribute('y', 5);
                    symbol.textContent = collapsedNodes.has(node.id) ? '+' : '−';
                    indicator.appendChild(symbol);

                    g.appendChild(indicator);
                }

                g.addEventListener('click', (e) => {
                    e.stopPropagation();
                    handleNodeClick(node);
                });

                svgGroup.appendChild(g);
            });

            updateStats();
        }

        function updateVisibility() {
            allNodes.forEach(node => {
                node.visible = true;
                
                // Check if any parent is collapsed
                let parent = node.parent;
                while (parent) {
                    if (collapsedNodes.has(parent.id)) {
                        node.visible = false;
                        break;
                    }
                    parent = parent.parent;
                }
            });
        }

        function handleNodeClick(node) {
            if (node.children.length > 0) {
                toggleCollapse(node);
            } else {
                showNodeInfo(node);
            }
        }

        function toggleCollapse(node) {
            if (collapsedNodes.has(node.id)) {
                collapsedNodes.delete(node.id);
            } else {
                collapsedNodes.add(node.id);
            }
            render();
        }

        function showNodeInfo(node) {
            const panel = document.getElementById('info-panel');
            const content = document.getElementById('info-content');
            
            const duration = node.startTime && node.endTime 
                ? ((new Date(node.endTime) - new Date(node.startTime)) / 1000).toFixed(2) + 's'
                : 'N/A';

            content.innerHTML = `
                <h3>${node.name}</h3>
                <div class="info-row">
                    <span class="info-label">Type</span>
                    <span class="info-value">${node.type}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Status</span>
                    <span class="info-value"><span class="status-badge status-${node.status}">${node.status}</span></span>
                </div>
                <div class="info-row">
                    <span class="info-label">Depth</span>
                    <span class="info-value">${node.depth}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Children</span>
                    <span class="info-value">${node.children.length}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Duration</span>
                    <span class="info-value">${duration}</span>
                </div>
                ${node.taskId ? `
                <div class="info-row">
                    <span class="info-label">Task ID</span>
                    <span class="info-value" style="font-size: 10px;">${node.taskId.substring(0, 20)}...</span>
                </div>` : ''}
            `;
            
            panel.classList.add('show');
        }

        function closeInfo() {
            document.getElementById('info-panel').classList.remove('show');
        }

        function updateStats() {
            const visible = allNodes.filter(n => n.visible).length;
            const maxDepth = allNodes.length > 0 ? Math.max(...allNodes.map(n => n.depth)) : 0;
            
            document.getElementById('totalTasks').textContent = allNodes.length;
            document.getElementById('visibleTasks').textContent = visible;
            document.getElementById('maxDepth').textContent = maxDepth;
        }

        function expandAll() {
            collapsedNodes.clear();
            render();
        }

        function collapseAll() {
            allNodes.forEach(node => {
                if (node.children.length > 0 && node.depth === 0) {
                    collapsedNodes.add(node.id);
                }
            });
            render();
        }

        function resetView() {
            scale = 1;
            layoutNodes();
            updateViewBox();
            render();
        }

        function loadWorkflow(data) {
            collapsedNodes.clear();
            parseWorkflow(data);
            layoutNodes();
            render();
            updateViewBox();
        }

        // Initialize on load
        init();
    </script>
</body>
</html>