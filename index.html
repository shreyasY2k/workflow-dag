<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Conductor Workflow DAG Viewer</title>
    <style>
        :root {
            --bg-primary: #0a0e1a;
            --bg-secondary: #111827;
            --accent-primary: #3b82f6;
            --accent-secondary: #8b5cf6;
            --text-primary: #f9fafb;
            --text-secondary: #9ca3af;
            --border: #1f2937;
            --success: #10b981;
            --warning: #f59e0b;
            --error: #ef4444;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Fira Code', monospace;
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
            height: 100vh;
        }
        
        #container {
            width: 100%;
            height: 100%;
            position: relative;
        }
        
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(17, 24, 39, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 20px;
            z-index: 100;
            min-width: 280px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4);
        }
        
        #controls h2 {
            font-size: 14px;
            font-weight: 600;
            letter-spacing: 0.05em;
            text-transform: uppercase;
            margin-bottom: 16px;
            color: var(--accent-primary);
        }
        
        .control-group {
            margin-bottom: 16px;
        }
        
        .control-group label {
            display: block;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-secondary);
            margin-bottom: 8px;
        }
        
        input[type="file"] {
            display: none;
        }
        
        .file-upload-btn {
            display: block;
            width: 100%;
            padding: 12px;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-family: inherit;
            font-size: 12px;
            font-weight: 600;
            letter-spacing: 0.03em;
            transition: all 0.3s ease;
            text-align: center;
        }
        
        .file-upload-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(59, 130, 246, 0.4);
        }
        
        button {
            width: 100%;
            padding: 10px;
            background: var(--bg-secondary);
            color: var(--text-primary);
            border: 1px solid var(--border);
            border-radius: 6px;
            cursor: pointer;
            font-family: inherit;
            font-size: 11px;
            font-weight: 500;
            letter-spacing: 0.03em;
            transition: all 0.2s ease;
            margin-bottom: 8px;
        }
        
        button:hover {
            background: var(--border);
            border-color: var(--accent-primary);
        }
        
        #stats {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(17, 24, 39, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 16px;
            z-index: 100;
            font-size: 11px;
            line-height: 1.6;
            min-width: 200px;
        }
        
        #stats div {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
        }
        
        #stats span:first-child {
            color: var(--text-secondary);
        }
        
        #stats span:last-child {
            color: var(--text-primary);
            font-weight: 600;
        }
        
        #nodeInfo {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(17, 24, 39, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 20px;
            z-index: 100;
            max-width: 350px;
            display: none;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4);
        }
        
        #nodeInfo h3 {
            font-size: 14px;
            margin-bottom: 12px;
            color: var(--accent-primary);
            font-weight: 600;
        }
        
        #nodeInfo .info-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 11px;
        }
        
        #nodeInfo .info-row span:first-child {
            color: var(--text-secondary);
        }
        
        #nodeInfo .info-row span:last-child {
            color: var(--text-primary);
            font-weight: 500;
        }
        
        .legend {
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid var(--border);
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            font-size: 11px;
        }
        
        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 4px;
            margin-right: 10px;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 200;
        }
        
        .spinner {
            width: 60px;
            height: 60px;
            border: 3px solid var(--border);
            border-top-color: var(--accent-primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .toast {
            position: fixed;
            bottom: 30px;
            right: 30px;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-left: 3px solid var(--accent-primary);
            border-radius: 8px;
            padding: 16px 20px;
            z-index: 1000;
            font-size: 12px;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.3s ease;
            pointer-events: none;
        }
        
        .toast.show {
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto;
        }
    </style>
</head>
<body>
    <div id="loading">
        <div class="spinner"></div>
        <div>Initializing Renderer...</div>
    </div>
    
    <div id="container"></div>
    
    <div id="controls">
        <h2>Workflow Controls</h2>
        <div class="control-group">
            <label for="fileInput">Load Workflow JSON</label>
            <input type="file" id="fileInput" accept=".json">
            <label for="fileInput" class="file-upload-btn">Choose File</label>
        </div>
        <div class="control-group">
            <button id="expandAll">Expand All</button>
            <button id="collapseAll">Collapse All</button>
            <button id="resetView">Reset Camera</button>
        </div>
        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background: #3b82f6;"></div>
                <span>Simple Task</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #8b5cf6;"></div>
                <span>Sub-Workflow</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #10b981;"></div>
                <span>Fork/Join</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #f59e0b;"></div>
                <span>Decision</span>
            </div>
        </div>
    </div>
    
    <div id="stats">
        <div><span>Nodes:</span> <span id="nodeCount">0</span></div>
        <div><span>Edges:</span> <span id="edgeCount">0</span></div>
        <div><span>Depth:</span> <span id="depthCount">0</span></div>
        <div><span>FPS:</span> <span id="fps">0</span></div>
    </div>
    
    <div id="nodeInfo"></div>
    
    <div id="toast" class="toast"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // DAG Visualization Engine
        class WorkflowDAG {
            constructor(containerElement) {
                this.container = containerElement;
                this.nodes = [];
                this.edges = [];
                this.nodeMap = new Map();
                this.collapsedNodes = new Set();
                
                this.initScene();
                this.initCamera();
                this.initRenderer();
                this.initLights();
                this.initControls();
                this.initRaycaster();
                
                this.animate();
                
                window.addEventListener('resize', () => this.onWindowResize());
            }
            
            initScene() {
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x0a0e1a);
                this.scene.fog = new THREE.Fog(0x0a0e1a, 50, 200);
            }
            
            initCamera() {
                this.camera = new THREE.PerspectiveCamera(
                    60,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    1000
                );
                this.camera.position.set(0, 20, 50);
                this.camera.lookAt(0, 0, 0);
            }
            
            initRenderer() {
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.container.appendChild(this.renderer.domElement);
                
                document.getElementById('loading').style.display = 'none';
            }
            
            initLights() {
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
                this.scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(10, 20, 10);
                this.scene.add(directionalLight);
                
                const pointLight = new THREE.PointLight(0x3b82f6, 0.5, 100);
                pointLight.position.set(0, 10, 20);
                this.scene.add(pointLight);
            }
            
            initControls() {
                this.isDragging = false;
                this.previousMousePosition = { x: 0, y: 0 };
                
                this.renderer.domElement.addEventListener('mousedown', (e) => {
                    this.isDragging = true;
                    this.previousMousePosition = { x: e.clientX, y: e.clientY };
                });
                
                this.renderer.domElement.addEventListener('mousemove', (e) => {
                    if (this.isDragging) {
                        const deltaX = e.clientX - this.previousMousePosition.x;
                        const deltaY = e.clientY - this.previousMousePosition.y;
                        
                        this.camera.position.x -= deltaX * 0.05;
                        this.camera.position.y += deltaY * 0.05;
                        this.camera.lookAt(0, 0, 0);
                        
                        this.previousMousePosition = { x: e.clientX, y: e.clientY };
                    }
                });
                
                this.renderer.domElement.addEventListener('mouseup', () => {
                    this.isDragging = false;
                });
                
                this.renderer.domElement.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const delta = e.deltaY * 0.05;
                    this.camera.position.z += delta;
                    this.camera.position.z = Math.max(10, Math.min(150, this.camera.position.z));
                });
            }
            
            initRaycaster() {
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();
                
                this.renderer.domElement.addEventListener('click', (e) => {
                    if (this.isDragging) return;
                    
                    this.mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                    this.mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
                    
                    this.raycaster.setFromCamera(this.mouse, this.camera);
                    const intersects = this.raycaster.intersectObjects(this.scene.children, true);
                    
                    if (intersects.length > 0) {
                        const object = intersects[0].object;
                        if (object.userData.nodeData) {
                            this.onNodeClick(object.userData.nodeData);
                        }
                    } else {
                        document.getElementById('nodeInfo').style.display = 'none';
                    }
                });
            }
            
            loadWorkflow(workflowData) {
                this.clearScene();
                
                const parsedNodes = this.parseWorkflow(workflowData);
                this.layoutNodes(parsedNodes);
                this.createEdges();
                
                this.updateStats();
                this.showToast('Workflow loaded successfully');
            }
            
            parseWorkflow(data) {
                const nodes = [];
                let nodeId = 0;
                
                const traverse = (tasks, parent = null, depth = 0) => {
                    if (!tasks || !Array.isArray(tasks)) return;
                    
                    tasks.forEach(task => {
                        const node = {
                            id: nodeId++,
                            name: task.name,
                            taskReferenceName: task.taskReferenceName,
                            type: task.type,
                            parent: parent,
                            depth: depth,
                            children: [],
                            collapsed: false
                        };
                        
                        nodes.push(node);
                        this.nodeMap.set(node.id, node);
                        
                        if (parent) {
                            parent.children.push(node);
                        }
                        
                        // Handle sub-workflows
                        if (task.type === 'SUB_WORKFLOW' && task.subWorkflowParam && task.subWorkflowParam.workflowDefinition) {
                            traverse(task.subWorkflowParam.workflowDefinition.tasks, node, depth + 1);
                        }
                        
                        // Handle fork tasks
                        if (task.type === 'FORK_JOIN' && task.forkTasks) {
                            task.forkTasks.forEach(forkBranch => {
                                traverse(forkBranch, node, depth + 1);
                            });
                        }
                        
                        // Handle decision cases
                        if (task.type === 'DECISION' && task.decisionCases) {
                            Object.values(task.decisionCases).forEach(caseTasks => {
                                traverse(caseTasks, node, depth + 1);
                            });
                        }
                        
                        // Handle default case
                        if (task.defaultCase) {
                            traverse(task.defaultCase, node, depth + 1);
                        }
                    });
                };
                
                traverse(data.tasks || []);
                return nodes;
            }
            
            layoutNodes(nodes) {
                const levels = {};
                
                nodes.forEach(node => {
                    if (!levels[node.depth]) {
                        levels[node.depth] = [];
                    }
                    levels[node.depth].push(node);
                });
                
                const maxDepth = Math.max(...Object.keys(levels).map(Number));
                const horizontalSpacing = 15;
                const verticalSpacing = 12;
                
                Object.keys(levels).forEach(depth => {
                    const levelNodes = levels[depth];
                    const levelWidth = levelNodes.length * horizontalSpacing;
                    const startX = -levelWidth / 2;
                    
                    levelNodes.forEach((node, index) => {
                        const x = startX + index * horizontalSpacing;
                        const y = -depth * verticalSpacing;
                        const z = 0;
                        
                        this.createNode(node, x, y, z);
                    });
                });
            }
            
            createNode(nodeData, x, y, z) {
                const hasChildren = nodeData.children.length > 0;
                const size = hasChildren ? 1.5 : 1.2;
                
                const geometry = new THREE.BoxGeometry(size, size, size);
                const color = this.getNodeColor(nodeData.type);
                const material = new THREE.MeshPhongMaterial({
                    color: color,
                    emissive: color,
                    emissiveIntensity: 0.2,
                    shininess: 100
                });
                
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(x, y, z);
                mesh.userData.nodeData = nodeData;
                
                this.scene.add(mesh);
                this.nodes.push({ mesh, data: nodeData });
                
                // Add edge glow for collapsible nodes
                if (hasChildren) {
                    const edgeGeometry = new THREE.EdgesGeometry(geometry);
                    const edgeMaterial = new THREE.LineBasicMaterial({ 
                        color: 0xffffff,
                        linewidth: 2
                    });
                    const edges = new THREE.LineSegments(edgeGeometry, edgeMaterial);
                    mesh.add(edges);
                }
                
                // Add text sprite
                this.createTextLabel(nodeData.taskReferenceName || nodeData.name, x, y - 1, z);
            }
            
            createTextLabel(text, x, y, z) {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 512;
                canvas.height = 128;
                
                context.fillStyle = '#1f2937';
                context.fillRect(0, 0, canvas.width, canvas.height);
                
                context.font = 'bold 48px monospace';
                context.fillStyle = '#f9fafb';
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                
                const maxWidth = canvas.width - 40;
                const truncated = text.length > 20 ? text.substring(0, 20) + '...' : text;
                context.fillText(truncated, canvas.width / 2, canvas.height / 2);
                
                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.position.set(x, y, z);
                sprite.scale.set(4, 1, 1);
                
                this.scene.add(sprite);
            }
            
            createEdges() {
                this.nodes.forEach(({ mesh, data }) => {
                    data.children.forEach(child => {
                        const childNode = this.nodes.find(n => n.data.id === child.id);
                        if (childNode && !this.collapsedNodes.has(data.id)) {
                            this.createEdge(mesh.position, childNode.mesh.position);
                        }
                    });
                });
            }
            
            createEdge(start, end) {
                const points = [];
                points.push(new THREE.Vector3(start.x, start.y, start.z));
                points.push(new THREE.Vector3(end.x, end.y, end.z));
                
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({
                    color: 0x3b82f6,
                    opacity: 0.6,
                    transparent: true
                });
                
                const line = new THREE.Line(geometry, material);
                this.scene.add(line);
                this.edges.push(line);
            }
            
            getNodeColor(type) {
                const colors = {
                    'SUB_WORKFLOW': 0x8b5cf6,
                    'FORK_JOIN': 0x10b981,
                    'JOIN': 0x10b981,
                    'DECISION': 0xf59e0b,
                    'SWITCH': 0xf59e0b,
                    'SIMPLE': 0x3b82f6,
                    'HTTP': 0x3b82f6,
                    'EVENT': 0xec4899,
                    'WAIT': 0x6366f1
                };
                
                return colors[type] || 0x3b82f6;
            }
            
            onNodeClick(nodeData) {
                const hasChildren = nodeData.children.length > 0;
                
                if (hasChildren) {
                    const isCollapsed = this.collapsedNodes.has(nodeData.id);
                    
                    if (isCollapsed) {
                        this.expandNode(nodeData);
                    } else {
                        this.collapseNode(nodeData);
                    }
                }
                
                this.showNodeInfo(nodeData);
            }
            
            collapseNode(nodeData) {
                this.collapsedNodes.add(nodeData.id);
                
                const hideChildren = (node) => {
                    node.children.forEach(child => {
                        const childNode = this.nodes.find(n => n.data.id === child.id);
                        if (childNode) {
                            childNode.mesh.visible = false;
                            hideChildren(child);
                        }
                    });
                };
                
                hideChildren(nodeData);
                this.redrawEdges();
                this.showToast('Node collapsed');
            }
            
            expandNode(nodeData) {
                this.collapsedNodes.delete(nodeData.id);
                
                const showChildren = (node) => {
                    node.children.forEach(child => {
                        const childNode = this.nodes.find(n => n.data.id === child.id);
                        if (childNode) {
                            childNode.mesh.visible = true;
                            if (!this.collapsedNodes.has(child.id)) {
                                showChildren(child);
                            }
                        }
                    });
                };
                
                showChildren(nodeData);
                this.redrawEdges();
                this.showToast('Node expanded');
            }
            
            redrawEdges() {
                this.edges.forEach(edge => this.scene.remove(edge));
                this.edges = [];
                this.createEdges();
            }
            
            showNodeInfo(nodeData) {
                const infoPanel = document.getElementById('nodeInfo');
                infoPanel.innerHTML = `
                    <h3>${nodeData.taskReferenceName || nodeData.name}</h3>
                    <div class="info-row">
                        <span>Type:</span>
                        <span>${nodeData.type}</span>
                    </div>
                    <div class="info-row">
                        <span>Name:</span>
                        <span>${nodeData.name}</span>
                    </div>
                    <div class="info-row">
                        <span>Depth:</span>
                        <span>${nodeData.depth}</span>
                    </div>
                    <div class="info-row">
                        <span>Children:</span>
                        <span>${nodeData.children.length}</span>
                    </div>
                    ${nodeData.children.length > 0 ? `
                        <div class="info-row">
                            <span>Status:</span>
                            <span>${this.collapsedNodes.has(nodeData.id) ? 'Collapsed' : 'Expanded'}</span>
                        </div>
                    ` : ''}
                `;
                infoPanel.style.display = 'block';
            }
            
            expandAll() {
                this.collapsedNodes.clear();
                this.nodes.forEach(({ mesh }) => {
                    mesh.visible = true;
                });
                this.redrawEdges();
                this.showToast('All nodes expanded');
            }
            
            collapseAll() {
                this.nodes.forEach(({ data }) => {
                    if (data.children.length > 0) {
                        this.collapsedNodes.add(data.id);
                    }
                });
                
                this.nodes.forEach(({ mesh, data }) => {
                    if (data.depth > 0) {
                        mesh.visible = false;
                    }
                });
                
                this.redrawEdges();
                this.showToast('All nodes collapsed');
            }
            
            resetCamera() {
                this.camera.position.set(0, 20, 50);
                this.camera.lookAt(0, 0, 0);
                this.showToast('Camera reset');
            }
            
            clearScene() {
                this.nodes.forEach(({ mesh }) => {
                    this.scene.remove(mesh);
                });
                this.edges.forEach(edge => {
                    this.scene.remove(edge);
                });
                
                // Remove sprites
                this.scene.children = this.scene.children.filter(child => 
                    !(child instanceof THREE.Sprite)
                );
                
                this.nodes = [];
                this.edges = [];
                this.nodeMap.clear();
                this.collapsedNodes.clear();
            }
            
            updateStats() {
                const visibleNodes = this.nodes.filter(({ mesh }) => mesh.visible).length;
                const maxDepth = Math.max(...this.nodes.map(({ data }) => data.depth));
                
                document.getElementById('nodeCount').textContent = visibleNodes;
                document.getElementById('edgeCount').textContent = this.edges.length;
                document.getElementById('depthCount').textContent = maxDepth;
            }
            
            showToast(message) {
                const toast = document.getElementById('toast');
                toast.textContent = message;
                toast.classList.add('show');
                
                setTimeout(() => {
                    toast.classList.remove('show');
                }, 3000);
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                // Rotate nodes slightly for visual effect
                this.nodes.forEach(({ mesh }) => {
                    mesh.rotation.y += 0.003;
                });
                
                // Update FPS
                if (!this.lastTime) this.lastTime = performance.now();
                const now = performance.now();
                const fps = Math.round(1000 / (now - this.lastTime));
                this.lastTime = now;
                document.getElementById('fps').textContent = fps;
                
                this.renderer.render(this.scene, this.camera);
            }
            
            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }
        }
        
        // Initialize application
        const container = document.getElementById('container');
        const dag = new WorkflowDAG(container);
        
        // File upload handler
        document.getElementById('fileInput').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const data = JSON.parse(event.target.result);
                        dag.loadWorkflow(data);
                    } catch (error) {
                        dag.showToast('Error parsing JSON: ' + error.message);
                    }
                };
                reader.readAsText(file);
            }
        });
        
        // Control buttons
        document.getElementById('expandAll').addEventListener('click', () => dag.expandAll());
        document.getElementById('collapseAll').addEventListener('click', () => dag.collapseAll());
        document.getElementById('resetView').addEventListener('click', () => dag.resetCamera());
        
        // Sample workflow for testing
        const sampleWorkflow = {
            name: "sample_workflow",
            tasks: [
                {
                    name: "start_task",
                    taskReferenceName: "start",
                    type: "SIMPLE"
                },
                {
                    name: "process_workflow",
                    taskReferenceName: "sub_wf_1",
                    type: "SUB_WORKFLOW",
                    subWorkflowParam: {
                        workflowDefinition: {
                            tasks: [
                                {
                                    name: "nested_task_1",
                                    taskReferenceName: "nested_1",
                                    type: "SIMPLE"
                                },
                                {
                                    name: "nested_task_2",
                                    taskReferenceName: "nested_2",
                                    type: "SIMPLE"
                                }
                            ]
                        }
                    }
                },
                {
                    name: "fork_processing",
                    taskReferenceName: "fork_1",
                    type: "FORK_JOIN",
                    forkTasks: [
                        [
                            {
                                name: "branch_1_task",
                                taskReferenceName: "branch_1",
                                type: "SIMPLE"
                            }
                        ],
                        [
                            {
                                name: "branch_2_task",
                                taskReferenceName: "branch_2",
                                type: "SIMPLE"
                            }
                        ]
                    ]
                },
                {
                    name: "end_task",
                    taskReferenceName: "end",
                    type: "SIMPLE"
                }
            ]
        };
        
        // Load sample workflow on start
        setTimeout(() => {
            dag.loadWorkflow(sampleWorkflow);
        }, 500);
    </script>
</body>
</html>